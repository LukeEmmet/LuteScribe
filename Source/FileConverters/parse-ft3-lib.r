REBOL [
    title: {parser for fronimo ft3 files (decompressed)}
    usage: {edit the script to pass different files. Given that .ft3 files
        are gzipped up, rename the ft3 to *.gz, and use a normal zip
        utility to extract the file therein. This extracted file can be
        analysed by this script as well as the previous .ft2. 
    }
    
    notes: {
        Based on parsing MFC file format CArchive generated by Fronimo.
        
        Still some more sleuthing to do, to work out wha other slots in the format
        are for
    }
    
    todo: {
        time signatures
        dotted rhythms
        note ornaments
        note fingerings
        bar endings
        author/title
        
    
    }
    
]


;===================================================
;
;    LuteScribe, a GUI tool to view and edit lute tabulature 
;    (and for related plucked instruments).
;
;    Copyright (C) 2018, Luke Emmet 
;
;    Email: luke [dot] emmet [at] orlando-lutes [dot] com
;
;    This program is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 3 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program.  If not, see <https://www.gnu.org/licenses/>.
;
;===================================================

chord-prototype: make object! [
    flag: ""
    flag-group: none
    notes: []
    decorations: []
]

bar-prototype: make object! [

    start-line: ""
    end-line: ""
    chords: []
    decorations: []
]

note-prototype: make object! [
    string: ""
    fret: ""
    decorations: []
    flag:  #{00}
]

header-prototype: make object! [
    author: ""
    composer: ""
    title: "Untitled"
    remarks: ""
    source: ""
    comments: []
    commands: [
        "$flagstyle=thin"
        "$charstyle=robinson"
    ]
]

error-chord: funct [text] [
    
]

;---function for parsing a bar data structure
extract-bar: funct [data  /local result] [
        
    bar: make bar-prototype []
    
    data: skip data 28
    
    num-chords: 1 + to-integer data/1
    data: skip data 4
    
    char-count: 0
    result: copy []
    
    continue: true
    
    
    continue-seek: true
    chord-data: seek-chord data

      while [continue-seek and not none? chord-data] [
        chord: make chord-prototype []
        
        
         data: chord-data


         flag: pick "xw012345" (1 + (to-integer data/1))        ;--data/1 = 0 means continue or no new chord

         flag-detail: data/2
         flag-slot1: data/3
         flag-slot2: data/4
          
          if none? flag [
            err-chord: make chord-prototype [flag: join "%flag? " to-integer data/1]   ;**TBD, not sure of the correct interpretation of such data
            append/only bar/chords err-chord
            flag: "x"
          ]
          
          chord/flag: to-string flag
          ;print join "flag: " flag
          if (to-binary flag-detail) = #{10} [
            append chord/flag "."
          ]
          
          
          if (to-binary flag-detail) = #{02} [chord/flag-group: 'start]
          if (to-binary flag-detail) = #{04} [chord/flag-group: 'middle]
          if (to-binary flag-detail) = #{08} [chord/flag-group: 'end]
          
          data: skip data 4
             while [continue-seek and at-next-note data] [
                    
                     note: make note-prototype []
                     
                    ;check the item is a note on a normal string (up to 10th course)
                     either ((to-binary data/1) >= #{02}) and ((to-binary data/1) <= #{0A}) [
                        ;normal note
                         ;print "__"
                         candidate-string:   to-integer data/1
                         string:  pick "0123456789"  candidate-string
                         
                        
                        fret: data/2 
                        note-slot1: data/3        ;ornaments/fingering
                        note-slot2: data/4        ;ornaments/fingering
                        note-slot3: data/5        ;includes note flags such as fretted strings below 6th course

                        ;print rejoin [ "   string: " string  " fret: " fret ]
                        data: skip data 5

                        note/string: to-string string
                        note/fret:  to-string fret
                        note/flag: to-binary note-slot3

                        append/only chord/notes note

                    ] [
                        ;some other thing
                        at-data:  reduce [ to-binary data/1 to-binary data/2]
                        
                        either (at-data = [#{A3} #{38}]) [
                            ;lets skip over these
                            continue-seek: false
                            break
                        ] [
                        
                            data: skip data 5
                        ]
                        
                    ]
               ]
                
                either continue-seek [
                    append/only bar/chords chord
                    chord-data: seek-chord data
                ] [
                    break
                ]

      ]
        
      ;return the bar
     :bar
]

at-next-note: funct [data] [
    ;detects if we are at another note in the current chord
        
        ok-min: (to-binary data/2) >= #{30}
        ok-max: (to-binary data/2) <= #{39}
        bourdon: ((to-binary data/2) >= #{61}) and ((to-binary data/2) <= #{66} )       ;up to fret f on bourdons

        on-string: ((to-binary data/1) >= #{02}) and ((to-binary data/1) <= #{0A})
        
        return   ((ok-min and ok-max) or bourdon)
    
]


seek-chord: funct [data] [
    ;---seek further into the data to find the next chord
    ;---identified by a fret marker in the range 0-9
    ;---then back track to the flag for that chord
    result: none
    
    while [(not tail? data) and (#{ff} <> to-binary data/1)] [
        

       on-string:  ((to-binary data/1) >= #{02}) and ((to-binary data/1) <= #{0A})

        if  at-next-note data [
            data: skip data  -4            
            result: data
            break
        ]
        data: skip data 1
    ]

    :result
    
]

extract-rtf: funct [content] [
    result: copy ""
    
    
    either ("{\rtf" = copy/part content  5) [
        ;--extract rtf - very simplistic, assumes it always has
        ;--a single para, having a font size \fs-XX just before the content
        parse content [
            thru "\pard\" thru "\fs" thru " "  copy found to "\" thru "\par" to end
        ]
         if not none? found [result:  found]
    ] [
        result:  content
    ]
    
    :result
]

parse-headers: funct [data header-obj] [

    header: skip data 8
    
    ;---first RTF slot is the piece title
    string-length: to-integer header/1
    header: skip header 1
    header-obj/title: extract-rtf copy/part header string-length
    header: skip header (string-length)
    
    ;---not sure what this second slot is for yet
    string-length: to-integer header/1
    header: skip header 1
    header-obj/author: extract-rtf copy/part header string-length
    header: skip header (string-length )
    
    ;---3rd slot seems to be the composer of the piece
    string-length: to-integer header/1
    header: skip header 1
    header-obj/composer: extract-rtf copy/part header string-length
    header: skip header (string-length )
    

]
    

parse-fronimo-binary-content: funct [data header-obj output-block] [

    marker: to-string #{0380}       ;---denotes next object in MFC, or type 03 (CBar in our case)

    counter: 0
    bar-counter: 0
     
    state-buffer: copy ""

     parse/all data [
            
        copy preamble to "CPiece" thru "CPiece"
        copy header to "CBar" thru "CBar"
        (parse-headers header header-obj)
        
        any [
            [
                copy bar to marker
                
                (
                    counter: counter + 1
                        append output-block bar
                    )
                    thru marker
            ]
        ]
        
        copy rest to end
        (append output-block rest)
        
        end
    ]
    

]

emit-headers: funct [header] [
    result: copy ""
    
    append/only result "{"
    
    if 0 < length? header/title [
        append/only  result  rejoin [header/title ]
    ]
    
    if 0 < length? header/composer [
        append/only  result  rejoin [ "/" header/composer ]
    ]
    
    append/only result join "}" newline
    
     foreach entry header/commands  [
        append/only  result  rejoin [ entry newline]
    ]
    
    foreach entry header/comments [
        foreach line parse/all entry "^/" [
            append/only  result  rejoin ["%" line newline]
        ]
    ]

    :result

]

get-flag-info: funct [previous this following] [

        result: copy ""
    
        either none? following [
                either not none?  previous [
                    either (this/flag = previous/flag) [
                        result: "x"
                    ] [
                        ;result: "x"
                        append result this/flag
                    ]
                ] [
                    append result this/flag
                ]
        ] [
            ;first flag, with following
            either ('start = this/flag-group) [
                append result this/flag
                either ('start <> following/flag-group) [
                    append result "#"
                ] [
                    append result ""
                ]
            ] [
               
                either not none?  previous [
                    either (this/flag = previous/flag) [
                        result: "x"
                    ] [
                        ;result: "x"
                        append result this/flag
                    ]
                ] [
                    append result this/flag
                ]
            ]
            
        ]
        
    :result
]

emit-bar: funct [bar] [
    ;---converts the nested structure to collection of blocks required for tab generation
        result: copy []
        
        append/only result ["b" "" "" "" "" "" "" "" "" ]
                
          
          for n 1 (length? bar/chords) 1 [
            chord: pick bar/chords n
            previous: pick bar/chords (n - 1)
            following: pick bar/chords (n + 1)
            
            chord-blk: copy [" " " " " " " " " " " " " " " "]
                        
            chord-blk/1: get-flag-info previous chord following
            
            
            foreach note  chord/notes [
                either 7 =  to-integer  note/string [
                    ;--use the note flag slot to determine what kind of string or fret we have here...
                    switch note/flag [
                        #{00} [
                            ;fretted 7th course, letter will be given
                            french-fret: note/fret
                        ]
                        #{20} [
                            ;--open diapason, number indicates string below 7th
                            french-fret: note/fret      ;this might be a number or a letter (e.g. fretted 7th course)
                            if not none? find "0123" to-string note/fret [
                                french-fret: pick  ["a" "/a" "//a" "///a" ]  (1 + to-integer note/fret)
                            ]
                        ]
                        #{48} [
                            ;means a fretted 8th - letter will be given
                            french-fret: join "/" note/fret
                        ]
                        
                        ;---could be others here - fretted 9th, 10th etc?
                    ]
                        
                    ;probe note
                ] [
                    
                    french-fret:  to-string pick "abcdefghiklmnopqrst" (1 + to-integer note/fret)       ;--no j (same as i)
                ]
                
               attempt [
                    ;print join "string: "  to-integer probe note/string
                   ;print mold chord-blk
                
                    poke chord-blk (1 + to-integer note/string) french-fret
                ]
            ]
            
            ;print mold chord-blk
            append/only result chord-blk
          ]
  
        :result
]


parse-fronimo-file: funct [file-name] [
    
    result: copy  ""
    
    parse-bar-block: copy []
    output-block: copy []
    header-obj: make header-prototype []
    
    append header-obj/comments  "Converted by LuteScribe FT3 to TAB converter^/"
    
    ;---main parsing here
    parse-fronimo-binary-content (read/binary file-name) header-obj output-block
    
    append result emit-headers header-obj
    
    ;---start main content
    append result "^/^/"

    ;---start outputting content
    counter: 0
    
    foreach item output-block [
          counter: counter + 1

          bar: extract-bar item
          foreach line emit-bar bar [
                append result rejoin line
                append result newline
          ]
    ]
    
    append result "b"
    append result newline
    
    ;---write end of file to close
    append result "e"
    
    :result
]


;===TEST - change from 'comment to 'do to enable ===
comment [

    samples-folder:  {..\Samples\Ft3\}

    ;sample-file: {55_mrs_winters_jump\55_mrs_winters_jump.ft3}
    ;sample-file: {27_galliard\27_galliard.ft3}
    ;sample-file: {28_galliard_upon_bachelor\28_galliard_upon_bachelor.ft3}
    sample-file: {14a_langton_pavane\14a_langton_pavane.ft3}
    ;sample-file: {queen_elizabeths_galliard\queen_elizabeths_galliard.ft3}
    ;sample-file: {recercare_04\recercare_04.ft3}
    ;sample-file: {25_melancholy_galliard\25_melancholy_galliard.ft3}
    ;sample-file: {frogg_galliard\frogg_galliard.ft3}
    ;sample-file: {02 Piper's Pavan - Minus Lute 1-1.ft3}
    ;sample-file: {ec9faec4-2e64-443c-bb40-a46ba15c2454.tmp}

    if none? system/options/args [
        in-path: rejoin [ what-dir samples-folder sample-file]
        out-path: "d:\desktop\out3.txt"
        
        system/options/args: reduce [in-path out-path]
    ]
    
    arg-block: probe to-block system/options/args
    in-file: to-rebol-file arg-block/1
    out-file: to-rebol-file arg-block/2
    
    print ""
    probe content: parse-fronimo-file to-rebol-file in-path
    write out-file content
    
]


